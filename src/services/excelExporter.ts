/**
 * Excel Export Service
 * Provides comprehensive Excel export functionality for reports
 */

import * as XLSX from 'xlsx';
import type { TimeEntry, Project, Client } from '../types';
import type { ReportMetrics } from './advancedReporting';

export interface ExcelExportConfig {
  includeCharts: boolean;
  includeSummary: boolean;
  includeDetailedData: boolean;
  includeTrends: boolean;
  dateFormat: string;
  companyName?: string;
  reportTitle?: string;
  generatedBy?: string;
}

class ExcelExporter {
  /**
   * Export comprehensive report to Excel
   */
  async exportReport(
    metrics: ReportMetrics,
    timeEntries: TimeEntry[],
    projects: Project[],
    clients: Client[],
    config: ExcelExportConfig
  ): Promise<Blob> {
    const workbook = XLSX.utils.book_new();

    // Add summary sheet
    if (config.includeSummary) {
      const summarySheet = this.createSummarySheet(metrics, config);
      XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary');
    }

    // Add detailed data sheet
    if (config.includeDetailedData) {
      const detailsSheet = this.createDetailedDataSheet(timeEntries, projects, clients);
      XLSX.utils.book_append_sheet(workbook, detailsSheet, 'Time Entries');
    }

    // Add projects analysis
    const projectsSheet = this.createProjectsSheet(metrics, projects);
    XLSX.utils.book_append_sheet(workbook, projectsSheet, 'Project Analysis');

    // Add trends sheet
    if (config.includeTrends) {
      const trendsSheet = this.createTrendsSheet(metrics);
      XLSX.utils.book_append_sheet(workbook, trendsSheet, 'Daily Trends');
    }

    // Add team performance (if available)
    if (metrics.topClients && metrics.topClients.length > 0) {
      const clientsSheet = this.createClientsSheet(metrics);
      XLSX.utils.book_append_sheet(workbook, clientsSheet, 'Client Analysis');
    }

    // Add efficiency analysis
    const efficiencySheet = this.createEfficiencySheet(metrics);
    XLSX.utils.book_append_sheet(workbook, efficiencySheet, 'Efficiency');

    // Generate Excel file
    const excelBuffer = XLSX.write(workbook, { 
      bookType: 'xlsx', 
      type: 'array',
      cellStyles: true,
    });

    return new Blob([excelBuffer], { 
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
    });
  }

  /**
   * Create summary sheet with key metrics
   */
  private createSummarySheet(metrics: ReportMetrics, config: ExcelExportConfig): XLSX.WorkSheet {
    const data = [
      ['TimeBeacon Analytics Report'],
      ['Generated on:', new Date().toLocaleDateString()],
      ['Report Period:', `${config.dateFormat || 'Custom Range'}`],
      ['Generated by:', config.generatedBy || 'TimeBeacon User'],
      [],
      ['📊 KEY METRICS'],
      ['Metric', 'Value', 'Status'],
      ['Total Hours Tracked', metrics.totalHours.toFixed(2), this.getStatusIndicator(metrics.totalHours, 40, 'hours')],
      ['Billable Hours', metrics.billableHours.toFixed(2), this.getStatusIndicator(metrics.billableHours, 30, 'hours')],
      ['Non-Billable Hours', metrics.nonBillableHours.toFixed(2), ''],
      ['Utilization Rate', `${metrics.utilizationRate.toFixed(1)}%`, this.getStatusIndicator(metrics.utilizationRate, 75, 'percentage')],
      ['Productivity Score', `${metrics.productivityScore.toFixed(1)}%`, this.getStatusIndicator(metrics.productivityScore, 80, 'percentage')],
      ['Average Session Length', `${metrics.averageSessionLength.toFixed(1)} min`, this.getStatusIndicator(metrics.averageSessionLength, 120, 'minutes')],
      ['Total Sessions', metrics.totalSessions.toString(), ''],
      [],
      ['💼 TOP PROJECTS (by hours)'],
      ['Rank', 'Project Name', 'Hours', 'Percentage'],
      ...metrics.topProjects.slice(0, 10).map((project, index) => [
        index + 1,
        project.name,
        project.hours.toFixed(2),
        `${project.percentage.toFixed(1)}%`
      ]),
      [],
      ['📈 PERFORMANCE INDICATORS'],
      ['Indicator', 'Current', 'Target', 'Status'],
      ['Daily Average Hours', (metrics.totalHours / 30).toFixed(1), '8.0', this.getPerformanceStatus(metrics.totalHours / 30, 8)],
      ['Consistency Score', (metrics.productivityScore / 100).toFixed(2), '0.85', this.getPerformanceStatus(metrics.productivityScore / 100, 0.85)],
      ['Project Focus', metrics.topProjects.length > 0 ? metrics.topProjects[0].percentage.toFixed(1) + '%' : '0%', '60%', ''],
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);

    // Apply formatting
    this.applyBasicFormatting(worksheet);
    
    // Set column widths
    worksheet['!cols'] = [
      { width: 25 },
      { width: 15 },
      { width: 12 },
      { width: 12 }
    ];

    return worksheet;
  }

  /**
   * Create detailed time entries sheet
   */
  private createDetailedDataSheet(
    timeEntries: TimeEntry[],
    projects: Project[],
    clients: Client[]
  ): XLSX.WorkSheet {
    const headers = [
      'Date',
      'Project',
      'Client',
      'Description',
      'Start Time',
      'End Time',
      'Duration (hours)',
      'Billable',
      'Hourly Rate',
      'Earnings',
      'Status',
      'Category',
      'Tags'
    ];

    const data = [
      headers,
      ...timeEntries.map(entry => {
        const project = projects.find(p => p.id === entry.projectId);
        const client = clients.find(c => c.id === entry.clientId);
        const durationHours = (entry.duration || 0) / 60;
        const earnings = durationHours * (entry.hourlyRate || 0);

        return [
          new Date(entry.date).toLocaleDateString(),
          project?.name || 'Unknown Project',
          client?.name || 'No Client',
          entry.description || '',
          entry.startTime || '',
          entry.endTime || '',
          durationHours.toFixed(2),
          entry.billable ? 'Yes' : 'No',
          entry.hourlyRate?.toFixed(2) || '0.00',
          earnings.toFixed(2),
          entry.status || 'Pending',
          project?.category || '',
          entry.tags?.join(', ') || ''
        ];
      })
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);

    // Apply formatting
    this.applyTableFormatting(worksheet, headers.length);

    // Set column widths
    worksheet['!cols'] = [
      { width: 12 }, // Date
      { width: 20 }, // Project
      { width: 18 }, // Client
      { width: 30 }, // Description
      { width: 10 }, // Start Time
      { width: 10 }, // End Time
      { width: 12 }, // Duration
      { width: 10 }, // Billable
      { width: 12 }, // Rate
      { width: 12 }, // Earnings
      { width: 12 }, // Status
      { width: 15 }, // Category
      { width: 20 }, // Tags
    ];

    return worksheet;
  }

  /**
   * Create projects analysis sheet
   */
  private createProjectsSheet(metrics: ReportMetrics, projects: Project[]): XLSX.WorkSheet {
    const data = [
      ['Project Performance Analysis'],
      ['Generated on:', new Date().toLocaleDateString()],
      [],
      ['📋 PROJECT SUMMARY'],
      ['Project Name', 'Hours Logged', 'Percentage', 'Status', 'Budget Used'],
      ...metrics.topProjects.map(projectMetric => {
        const project = projects.find(p => p.name === projectMetric.name);
        const budgetUsed = project?.budget ? 
          ((projectMetric.hours * (project.hourlyRate || 50)) / project.budget * 100).toFixed(1) + '%' : 
          'No Budget';
        
        return [
          projectMetric.name,
          projectMetric.hours.toFixed(2),
          `${projectMetric.percentage.toFixed(1)}%`,
          this.getProjectStatus(projectMetric.percentage),
          budgetUsed
        ];
      }),
      [],
      ['⚡ EFFICIENCY ANALYSIS'],
      ['Project', 'Planned Hours', 'Actual Hours', 'Efficiency %', 'Variance'],
      ...metrics.projectEfficiency.map(eff => [
        eff.project,
        eff.plannedHours.toFixed(1),
        eff.actualHours.toFixed(1),
        `${eff.efficiency.toFixed(1)}%`,
        (eff.plannedHours - eff.actualHours).toFixed(1)
      ]),
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);
    this.applyBasicFormatting(worksheet);

    worksheet['!cols'] = [
      { width: 25 },
      { width: 15 },
      { width: 12 },
      { width: 15 },
      { width: 15 }
    ];

    return worksheet;
  }

  /**
   * Create daily trends sheet
   */
  private createTrendsSheet(metrics: ReportMetrics): XLSX.WorkSheet {
    const data = [
      ['Daily Productivity Trends'],
      ['Analysis Period:', `${metrics.dailyTrends.length} days`],
      [],
      ['Date', 'Hours Tracked', 'Sessions', 'Avg Session Length', 'Productivity Index'],
      ...metrics.dailyTrends.map(trend => {
        const avgSessionLength = trend.sessions > 0 ? (trend.hours * 60) / trend.sessions : 0;
        const productivityIndex = this.calculateDailyProductivityIndex(trend.hours, trend.sessions);
        
        return [
          trend.date,
          trend.hours.toFixed(2),
          trend.sessions.toString(),
          `${avgSessionLength.toFixed(1)} min`,
          productivityIndex.toFixed(1)
        ];
      }),
      [],
      ['📊 TREND SUMMARY'],
      ['Metric', 'Average', 'Best Day', 'Lowest Day'],
      [
        'Daily Hours',
        (metrics.dailyTrends.reduce((sum, d) => sum + d.hours, 0) / metrics.dailyTrends.length).toFixed(2),
        Math.max(...metrics.dailyTrends.map(d => d.hours)).toFixed(2),
        Math.min(...metrics.dailyTrends.map(d => d.hours)).toFixed(2)
      ],
      [
        'Daily Sessions',
        (metrics.dailyTrends.reduce((sum, d) => sum + d.sessions, 0) / metrics.dailyTrends.length).toFixed(1),
        Math.max(...metrics.dailyTrends.map(d => d.sessions)).toString(),
        Math.min(...metrics.dailyTrends.map(d => d.sessions)).toString()
      ]
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);
    this.applyBasicFormatting(worksheet);

    worksheet['!cols'] = [
      { width: 12 },
      { width: 15 },
      { width: 12 },
      { width: 18 },
      { width: 16 }
    ];

    return worksheet;
  }

  /**
   * Create clients analysis sheet
   */
  private createClientsSheet(metrics: ReportMetrics): XLSX.WorkSheet {
    const data = [
      ['Client Performance Analysis'],
      [],
      ['🏢 CLIENT METRICS'],
      ['Client Name', 'Hours Logged', 'Revenue Generated', 'Avg Hourly Rate', 'Projects'],
      ...metrics.topClients.map(client => [
        client.name,
        client.hours.toFixed(2),
        `$${client.revenue.toFixed(2)}`,
        client.hours > 0 ? `$${(client.revenue / client.hours).toFixed(2)}` : '$0.00',
        '1' // This would be calculated from actual project relationships
      ]),
      [],
      ['💰 REVENUE BREAKDOWN'],
      ['Revenue Tier', 'Client Count', 'Total Revenue', 'Percentage'],
      ...this.analyzeRevenueDistribution(metrics.topClients)
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);
    this.applyBasicFormatting(worksheet);

    worksheet['!cols'] = [
      { width: 25 },
      { width: 15 },
      { width: 18 },
      { width: 16 },
      { width: 12 }
    ];

    return worksheet;
  }

  /**
   * Create efficiency analysis sheet
   */
  private createEfficiencySheet(metrics: ReportMetrics): XLSX.WorkSheet {
    const data = [
      ['Efficiency & Performance Analysis'],
      [],
      ['⚡ EFFICIENCY METRICS'],
      ['Project', 'Planned Hours', 'Actual Hours', 'Efficiency %', 'Time Variance', 'Status'],
      ...metrics.projectEfficiency.map(eff => [
        eff.project,
        eff.plannedHours.toFixed(1),
        eff.actualHours.toFixed(1),
        `${eff.efficiency.toFixed(1)}%`,
        `${(eff.plannedHours - eff.actualHours).toFixed(1)}h`,
        this.getEfficiencyStatus(eff.efficiency)
      ]),
      [],
      ['📈 PRODUCTIVITY RECOMMENDATIONS'],
      ['Area', 'Current Score', 'Target', 'Action Required'],
      [
        'Session Management',
        `${metrics.averageSessionLength.toFixed(0)} min avg`,
        '90-120 min',
        metrics.averageSessionLength < 90 ? 'Increase focus time' : 'Optimal'
      ],
      [
        'Utilization Rate',
        `${metrics.utilizationRate.toFixed(1)}%`,
        '>75%',
        metrics.utilizationRate < 75 ? 'Increase billable work' : 'Excellent'
      ],
      [
        'Project Focus',
        `${metrics.topProjects.length} active`,
        '<5 active',
        metrics.topProjects.length > 5 ? 'Reduce project count' : 'Good focus'
      ]
    ];

    const worksheet = XLSX.utils.aoa_to_sheet(data);
    this.applyBasicFormatting(worksheet);

    worksheet['!cols'] = [
      { width: 20 },
      { width: 15 },
      { width: 15 },
      { width: 12 },
      { width: 15 },
      { width: 20 }
    ];

    return worksheet;
  }

  // Helper methods
  private getStatusIndicator(value: number, target: number, type: string): string {
    const ratio = value / target;
    if (ratio >= 1) return '🟢 Excellent';
    if (ratio >= 0.8) return '🟡 Good';
    if (ratio >= 0.6) return '🟠 Fair';
    return '🔴 Needs Improvement';
  }

  private getPerformanceStatus(current: number, target: number): string {
    const ratio = current / target;
    if (ratio >= 1) return '✅ Target Met';
    if (ratio >= 0.9) return '🎯 Close';
    return '⚠️ Below Target';
  }

  private getProjectStatus(percentage: number): string {
    if (percentage >= 30) return 'Primary Focus';
    if (percentage >= 15) return 'Active';
    if (percentage >= 5) return 'Minor';
    return 'Minimal';
  }

  private getEfficiencyStatus(efficiency: number): string {
    if (efficiency >= 100) return '🟢 On/Under Budget';
    if (efficiency >= 80) return '🟡 Slight Overrun';
    return '🔴 Over Budget';
  }

  private calculateDailyProductivityIndex(hours: number, sessions: number): number {
    // Simple productivity index based on hours and session distribution
    const hourScore = Math.min(hours / 8 * 100, 100);
    const sessionScore = sessions > 0 ? Math.min((hours * 60) / sessions / 120 * 100, 100) : 0;
    return (hourScore * 0.6 + sessionScore * 0.4);
  }

  private analyzeRevenueDistribution(clients: any[]): any[][] {
    const tiers = [
      { name: 'High Value (>$1000)', min: 1000, count: 0, revenue: 0 },
      { name: 'Medium Value ($500-$1000)', min: 500, count: 0, revenue: 0 },
      { name: 'Low Value (<$500)', min: 0, count: 0, revenue: 0 }
    ];

    const totalRevenue = clients.reduce((sum, c) => sum + c.revenue, 0);

    clients.forEach(client => {
      if (client.revenue >= 1000) {
        tiers[0].count++;
        tiers[0].revenue += client.revenue;
      } else if (client.revenue >= 500) {
        tiers[1].count++;
        tiers[1].revenue += client.revenue;
      } else {
        tiers[2].count++;
        tiers[2].revenue += client.revenue;
      }
    });

    return tiers.map(tier => [
      tier.name,
      tier.count.toString(),
      `$${tier.revenue.toFixed(2)}`,
      totalRevenue > 0 ? `${(tier.revenue / totalRevenue * 100).toFixed(1)}%` : '0%'
    ]);
  }

  private applyBasicFormatting(worksheet: XLSX.WorkSheet): void {
    // This would apply cell formatting in a real implementation
    // For now, just set some basic properties
    if (!worksheet['!ref']) return;

    const range = XLSX.utils.decode_range(worksheet['!ref']);
    
    // Header formatting would go here
    for (let row = range.s.r; row <= Math.min(range.s.r + 3, range.e.r); row++) {
      for (let col = range.s.c; col <= range.e.c; col++) {
        const cell = worksheet[XLSX.utils.encode_cell({ r: row, c: col })];
        if (cell) {
          cell.s = { font: { bold: true } };
        }
      }
    }
  }

  private applyTableFormatting(worksheet: XLSX.WorkSheet, headerCount: number): void {
    // Table formatting would be applied here
    // For now, just mark the header row
    if (!worksheet['!ref']) return;

    const range = XLSX.utils.decode_range(worksheet['!ref']);
    
    // Header row formatting
    for (let col = range.s.c; col < headerCount; col++) {
      const cell = worksheet[XLSX.utils.encode_cell({ r: 0, c: col })];
      if (cell) {
        cell.s = { 
          font: { bold: true },
          fill: { fgColor: { rgb: 'E5E5E5' } }
        };
      }
    }
  }
}

export const excelExporter = new ExcelExporter();